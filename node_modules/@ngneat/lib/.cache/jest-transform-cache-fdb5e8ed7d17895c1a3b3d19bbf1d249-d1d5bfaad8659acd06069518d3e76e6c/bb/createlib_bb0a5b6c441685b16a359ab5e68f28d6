1538a1840b40045b88fe9f60cc24b2a4
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLib = void 0;
const schematics_1 = require("@angular-devkit/schematics");
const fs = require("fs");
const operators_1 = require("rxjs/operators");
const files_1 = require("../utils/files");
const helpers_1 = require("../utils/helpers");
function resolveTSConfig() {
    // if Angular's version is 10+ we need to update tsconfig.base.json
    const tsConfigPath = fs.existsSync("tsconfig.base.json")
        ? "tsconfig.base.json"
        : "tsconfig.json";
    // take tsConfig from the fs because we do not need angular's changes.
    let sourceText = files_1.readFileFromFS(tsConfigPath);
    // clean comments from file.
    sourceText = sourceText.replace(/\/\*.+?\*\/|\/\/.*(?=[\n\r])/g, "");
    return { path: tsConfigPath, json: JSON.parse(sourceText) };
}
function toTree(ruleOrTree, tree, context) {
    return helpers_1.isFunction(ruleOrTree)
        ? ruleOrTree(tree, context)
        : ruleOrTree;
}
function removeLibFiles(tree) {
    tree.actions
        .filter((action) => !!action.path.match(/\.component|\.service/))
        .forEach((action) => tree.delete(action.path));
    return tree;
}
function updateTsConfig(host, name, libPath) {
    const tsConfig = resolveTSConfig();
    const paths = {
        [name]: [`${libPath}/src/public-api.ts`],
    };
    tsConfig.json.compilerOptions.paths = Object.assign(Object.assign({}, tsConfig.json.compilerOptions.paths), paths);
    return files_1.setJSON(host, tsConfig.path, tsConfig.json);
}
function updateKarmaConfig(host, libPath) {
    const karmaPath = `${libPath}/karma.conf.js`;
    if (host.exists(karmaPath)) {
        let karma = files_1.readFile(host, karmaPath);
        karma = karma.replace(/browsers:.*/, `browsers: [process.env.CI ? 'ChromeHeadless' : 'Chrome'],`);
        karma = karma.replace(/singleRun:.*/, `singleRun: process.env.CI,`);
        files_1.writeFile(karmaPath, karma, host);
    }
    return host;
}
function packageJSONExtensions(options, scopeWithName) {
    const repoUrl = options.repositoryUrl || `https://github.com/${options.name}`;
    const libDistPath = scopeWithName.replace("@", "");
    const depthFromRootLib = "../" +
        scopeWithName
            .split("/")
            .map(() => "..")
            .join("/");
    const basicPkgJson = {
        version: "1.0.0",
        keywords: ["angular", "angular 2", options.name],
        license: "MIT",
        publishConfig: {
            access: "public",
        },
        bugs: {
            url: `${repoUrl}/issue`,
        },
        homepage: `${repoUrl}#readme`,
        repository: {
            type: "git",
            url: `${repoUrl}`,
        },
    };
    if (options.skipSchematics) {
        return basicPkgJson;
    }
    return Object.assign(Object.assign({}, basicPkgJson), { schematics: "./schematics/collection.json", scripts: {
            build: "tsc -p tsconfig.schematics.json",
            "copy:schemas": `cpx schematics/ng-add ${depthFromRootLib}/dist/${libDistPath}/`,
            "copy:collection": `cpx schematics/collection.json ${depthFromRootLib}/dist/${libDistPath}/schematics/`,
            postbuild: "npm run copy:schemas && npm run copy:collection",
        } });
}
function updatePackageJSON(options, libPath, tree, scopeWithName) {
    const packageJSONPath = `${libPath}/package.json`;
    if (!tree.exists(packageJSONPath)) {
        return tree;
    }
    const pkg = files_1.getJSON(tree, packageJSONPath);
    return files_1.setJSON(tree, packageJSONPath, Object.assign(Object.assign({}, pkg), packageJSONExtensions(options, scopeWithName)));
}
function createLib(options, scopeWithName, libPath, tree, context, isNx) {
    const libRule = schematics_1.externalSchematic(isNx ? "@nrwl/angular" : "@schematics/angular", "library", {
        name: scopeWithName,
    });
    const libTree$ = helpers_1.observify(toTree(libRule(tree, context), tree, context));
    return libTree$.pipe(operators_1.tap((tree) => updatePackageJSON(options, libPath, tree, scopeWithName)), operators_1.map(removeLibFiles), operators_1.map((libTree) => updateTsConfig(libTree, scopeWithName, libPath)), operators_1.map((libTree) => updateKarmaConfig(libTree, libPath)));
}
exports.createLib = createLib;
//# sourceMappingURL=create-lib.js.map